\chapter{Implementação e Testes}
\label{cap:Implementacao}
Devido as limitações das aplicações já existentes para a integração entre Kinect e Blender, optou-se pelo desenvolvimento de uma ferramenta que permitisse essa integração. Desta forma, nesse Capítulo é feita uma breve descrição da aplicação desenvolvida. Mais especificamente, na Seção 7.1 tem-se a arquitetura da aplicação desenvolvida. Na Seção 7.2 descreve-se como a comunicação interna da aplicação é realizada. Na Seção 7.3 tem-se as características do \textit{Addon} Kinected Blender, além do seu funcionamento com os \textit{armatures} do Blender. Na Seção 7.4 tem-se as características do \textit{Kinected Blender Receiver}, que é responsável pela comunicação com o sensor Kinect. Por fim, na Seção 7.5 tem-se o resultado dos testes realizados e na Seção 7.6 tem-se a descrição da animação gerada através da aplicação desenvolvida.

\section{Arquitetura da Aplicação}
Para o desenvolvimento da aplicação optou-se pela utilização do OpenNI pelo fato do \textit{framework} ser multiplataforma e possuir código aberto, assim como o Blender. O NiTE será utilizado como \textit{middleware} de apoio, devido suas facilidades para o processamento do esqueleto do usuário. 

Em um primeiro momento a aplicação foi inteiramente planejada dentro do Blender, em formato de \textit{addon}, através da utilização do \textit{Python Bindings}, devido a possibilidade de utilizar-se as funcionalidades do OpenNI e do NiTE na linguagem Python. Conforme pode-se observar na Figura \ref{fig:arquiteturaant}, o \textit{addon} Kinected Blender funcionaria juntamente com o Blender e se comunicaria com o OpenNI e o NiTE através do \textit{Python Bindings}. Já o OpenNI faria a comunicação com o sensor Kinect através do \textit{driver} do dispositivo, sendo que esse último não está embutido no OpenNI. De fato, no sistema operacional Windows seria utilizado o \textit{driver} oficial do Kinect, disponibilizado pela Microsoft, conforme especificação do OpenNI. Já em sistemas Linux seria utilizado o \textit{libfreenect}, que é um \textit{driver} não-oficial desenvolvido pela PrimeSense. A opção pelo \textit{libfreenect} deve-se a ausência de um \textit{driver} oficial para essa plataforma. Por fim, seria utilizado o sensor \textit{Kinect for Xbox 360} para os testes da aplicação, devido ao fato de ser o único sensor disponível para a realização dos testes. 

\begin{figure}[htbp]
 \centering
 \includegraphics[height=200px]{imagens/arquitetura_antiga.png}
 \caption{Arquitetura inicial da aplicação Kinected Blender.}
 \label{fig:arquiteturaant}
\end{figure}

Entretanto, não foi possível utilizar a arquitetura inicialmente planejada devido à existência de uma incompatibilidade entre o \textit{Python Bindings} e o  NiTE. As funções do  \textit{Python Bindings} são disponibilizadas através de uma \ac{DLL} que transcreve as funções originais de C++ para Python. Entretanto, durante o desenvolvimento deste trabalho foi constatado que a última versão desta DLL era incompatível com a última versão do NiTE, impossibilitando a utilização de algumas funções cruciais para a aplicação, como por exemplo, a busca da posição de um determinado ponto do usuário mapeado.

Uma solução seria realizar \textit{downgrade} da versão 2.2 para a versão 2.0, tanto na DLL quanto no NiTE. No entanto, a PrimeSense, empresa que desenvolvia o NiTE, o \textit{libfreenect} e o \textit{Python Bindings}, foi comprada pela Apple no final de novembro de 2013 \cite{BBC}, sendo que em 23 de abril de 2014 a Apple tirou do ar tanto o site da PrimeSense quanto o site da OpenNI, impossibilitando o \textit{download} de qualquer uma dessas ferramentas.

Com isso, a utilização de \textit{Python Bindings} tornou-se inviável, impossibilitando que toda a aplicação fosse escrita em Python e ocasionando uma mudança na arquitetura da aplicação. Na Figura \ref{fig:arquitetura} tem-se a nova arquitetura da aplicação desenvolvida. Observa-se que nesta arquitetura não foi utilizado o \textit{Python Bindings}, sendo necessária o desenvolvimento uma solução cliente-servidor para a comunicação entre o Kinect e o \textit{addon}. Nesta arquitetura, a aplicação cliente, chamada \textit{Kinected Blender Receiver}, processa os dados do Kinect, e após este processamento, envia os dados para a aplicação servidor, chamada \textit{Addon Kinected Blender}, através de uma comunicação por \textit{socket}. Além disso, como o \textit{libfreenect} também era disponibilizado pela PrimeSense e foi retirado do site, tornou-se inviável desenvolver a aplicação para Linux, uma vez que não existem outros \textit{drivers} disponíveis no momento.

\begin{figure}[htbp]
 \centering
 \includegraphics[height=200px]{imagens/arquitetura.png}
 \caption{Nova arquitetura da aplicação Kinected Blender.}
 \label{fig:arquitetura}
\end{figure}

Apesar dessas limitações, optou-se por continuar utilizando-se o OpenNI e o NiTE a fim de evitar mudanças significativas na arquitetura. De fato, grande parte do código já havia sido desenvolvido, e uma mudança muito grande na arquitetura impossibilitaria a conclusão deste trabalho em tempo hábil. Além disso, como o fato é muito recente, torna-se possível que a comunidade continue os projetos OpenNI e NiTE e que outras empresas auxiliem no desenvolvimento dos mesmos.

\section{Comunicação}
Devido ao fato da solução desenvolvida ser uma aplicação cliente-servidor, necessitou-se a criação de um canal de comunicação. Desta forma, a comunicação entre o \textit{Addon Kinected Blender} (servidor) e o \textit{Kinected Blender Receiver} (cliente) ocorre através de uma conexão \ac{UDP} local, através da porta 5775. Utilizou-se essa porta uma vez que a mesma não corresponde a nenhum serviço registrado \cite{iana}. 

Além disso, optou-se pelo protocolo UDP devido ao fato do protocolo \ac{TCP} ocasionar atrasos durante o processamento da animação em meio aos testes realizado. Este atraso deve-se ao fato do TCP requisitar a confirmação de entrega dos pacotes, o que inviabilizou o uso deste protocolo para a criação de animações em tempo real. Por fim, utilizou-se um \textit{socket} não-bloqueante com o objetivo das aplicações não ``travarem'' no aguardo da recepção de uma mensagem.

\section{Addon Kinected Blender}
O \textit{addon} foi desenvolvido na linguagem Python e sua interface gráfica foi desenvolvida utilizando-se a API do Blender. Este \textit{addon} inicializa um componente de tela no Blender, chamado de \textit{Kinected Blender}, e possui um botão de ``Start'', conforme pode ser observado na Figura \ref{fig:addonk}.

\begin{figure}[htbp]
 \centering
 \includegraphics[height=180px]{imagens/addon.PNG}
 \caption{\textit{Addon} Kinected Blender ativado.}
 \label{fig:addonk}
\end{figure}

No momento em que o botão de ``Start'' é pressionado, o Blender inicializa o servidor UDP e fica no aguardo de dados do Kinect. Ao receber as mensagens, o \textit{addon} executa o processamento dessas através de uma função modal. Esse tipo de função no Blender apresenta como objetivo executar processos em um intervalo de tempo determinado, o que impede que a aplicação ``trave'' durante a execução de um \textit{script} Python. O intervalo de tempo ideal para atualização da tela nesta aplicação foi estimada em 60 quadros por segundo. Com um número menor de quadros obteve-se pouca flexibilidade de manipulação da animação, enquanto que um número maior de quadros não foi possível de ser processado pelo Blender.

A função modal foi implementada através do uso de expressões regulares, e é responsável pela identificação dos dados pertencentes a cada ponto mapeado pelo Kinect. Os dados identificados pelas expressões regulares são transmitidos à objetos específicos do Blender, alterando sua posição em relação as coordenadas \textit{x}, \textit{y} e \textit{z}. Os únicos objetos que não podem ter sua posição alteradas de forma direta são os objetos do tipo \textit{bone}, sendo que para movê-los deve-se adicionar uma restrição no \textit{bone} de forma copiar o movimento de outro objeto, como por exemplo, um cubo. Ou seja, as posições desses objetos são alteradas e esses movimentos são copiados para os \texti{bones} correspondentes. Estes objetos devem apresentar os nomes da Tabela \ref{tab:mapeamento} para poderem ser mapeados aos \texti{bones}.

\newpage
\begin{table}[!ht]
		\centering
		\caption{Tabela para mapeamento de objetos vinculados às partes do corpo.}
    \label{tab:mapeamento}
    \begin{tabular}{| l | l | }
    \hline
    Objeto & Função \\ \hline
		E.Head & objeto a ser controlado pela cabeça \\ \hline
    E.Neck & objeto a ser controlado pelo pescoço \\ \hline
    E.Shoulder.L & objeto a ser controlado pelo ombro esquerdo \\ \hline
    E.Shoulder.R & objeto a ser controlado pelo ombro direito \\ \hline
    E.Elbow.L & objeto a ser controlado pelo cotovelo esquerdo \\ \hline
    E.Elbow.R & objeto a ser controlado pelo cotovelo direito \\ \hline
    E.Hand.L & objeto a ser controlado pelo punho esquerdo \\ \hline
    E.Hand.R & objeto a ser controlado pelo punho direito \\ \hline
    E.Torso & objeto a ser controlado pelo tronco \\ \hline
    E.Hip.L & objeto a ser controlado pelo quadril esquerdo \\ \hline
    E.Hip.R & objeto a ser controlado pelo quadril direito\\ \hline
    E.Knee.L & objeto a ser controlado pelo joelho esquerdo \\ \hline
    E.Knee.R & objeto a ser controlado pelo joelho direito \\ \hline
    E.Foot.L & objeto a ser controlado pelo tornozelo esquerdo \\ \hline
    E.Foot.R & objeto a ser controlado pelo tornozelo direito \\ \hline
    \end{tabular}
\end{table}

Caso algum objeto não seja encontrado, os dados referentes a esse serão descartados, ou seja, o \textit{addon} só irá transmitir os dados para os objetos existentes. Esta situação pode ser útil quando pretende-se animar somente uma parte do corpo de um personagem ou um personagem não-humanóide. Destaca-se ainda que, caso a opção \textit{Automatic keyframe insertion} esteja ativada (Figura \ref{fig:autoins}), o \textit{addon} irá gravar automaticamente os \textit{keyframes} da animação.

\begin{figure}[htbp]
 \centering
 \includegraphics[height=60px]{imagens/autoins.png}
 \caption{A função \textit{Auto keyframe insertion} deve estar ativada para gravação da animação.}
 \label{fig:autoins}
\end{figure}

\subsection{Mapeamento para \textit{Armature} / \textit{Bones}}
Conforme descrito anteriormente, o \textit{addon} transmite as informações processadas pelo Kinect somente para os objetos presentes na cena, não sendo possível a transmissão direta para \textit{bones} de um \textit{armature}. Isso se deve à necessidade de manter a proporção do personagem, ou seja, nem sempre o usuário será proporcionalmente do mesmo tamanho que o personagem modelado. 

Para manter esta proporção, foi utilizada uma técnica de mapeamento de \textit{bones} que encontra-se disponível no Blender. Os pontos mapeados do Kinect são transmitidos para objetos do tipo ``\textit{Empty}'' que possuem os nomes citados na Tabela \ref{tab:mapeamento}, sendo que objetos do tipo ``\textit{Empty}'' são utilizados somente para manipulação de restrições, não aparecendo em uma animação. Após isso, um \textit{armature} com tamanho proporcional do usuário é mapeado em cada \textit{bone} correspondente no objeto ``\textit{Empty}''. Após isso, um segundo \textit{armature}, com o tamanho do personagem, deverá ser criado, sendo que cada \textit{bone} desse \textit{armature} deverá possuir um \textit{bone constraint} de ``\textit{Copy Rotation}'' de cada \textit{bone} do \textit{armature} mapeado anteriormente, fazendo com que os movimentos feitos com um \textit{armature} sejam copiados para outro (Figura \ref{fig:armature3}).

\begin{figure}[htbp]
 \centering
 \includegraphics[height=180px]{imagens/armature3.PNG}
 \caption{\textit{Armature} cinza mapeado no personagem e \textit{armature} rosa mapeada do usuário.}
 \label{fig:armature3}
\end{figure}

\section{Kinected Blender - Receptor}
A aplicação foi escrita em C++, linguagem primária suportada pelo OpenNI e pelo NiTE e não possui interface gráfica. O \textit{socket} deste programa é responsável por enviar mensagens para o \textit{Addon Kinected Blender}. Os dados enviados na mensagem são obtidos através do uso do NiTE, sendo que somente um usuário pode ser detectado por vez. Todos os 15 pontos do corpo suportados pelo NiTE são capturados, após a calibragem ser feita através a ``pose Psi''.

Cada junta do corpo é processada individualmente, entretanto, nem sempre o valor atual da junta é transmitido, evitando-se que ruídos sejam repassados para o Blender. O ruído da imagem é causado por interferência de luz do sol ou da própria luz infravermelha ao tentar alcançar pontos cegos gerados pelas sombras. Essas interferências fazem com que os pontos capturados pelo NiTE mudem de posição mesmo com o usuário parado. 

Para evitar que estes ruídos sejam passados para animação, é verificado o percentual de deslocamento de cada ponto e o seu grau de confiança. O grau de confiança é obtido através de um algoritmo do próprio NiTE, e informa a probabilidade de um determinado ponto estar realmente no local indicado. Já o percentual de deslocamento informa o quanto o ponto atual deslocou-se em relação à sua posição anterior. 

Testes foram realizados com o grau de confiança, sendo que os melhores resultados foram obtidos utilizando-se um grau de confiança de 40\%. Observa-se que valores superiores a 40\% obteve-se uma perda de naturalidade nos movimentos. Isso deve-se ao fato do algoritmo não conseguir capturar movimentos rápidos. Já valores inferiores a 40\% geravam uma grande quantidade de ruídos. 

Nos testes realizados com o percentual de deslocamento, os melhores resultados foram obtidos através da utilização do percentual de 2\%, sendo que com este percentual pequenos ruídos ainda são transmitidos. Já um valor superior a 2\%, apesar de gerar menos ruído, provocavaram uma perda de pequenos movimentos voluntários do usuário, ocasionando limitações na reprodução da animação.

\section{Testes Realizados}
Para a realização dos testes dos movimentos capturados do Kinect foi utilizada uma metodologia adaptada do trabalho de \citet{jobert}. No trabalho citado foram realizados testes para o reconhecimento de gestos em jogos, enquanto neste trabalho os gestos serão adaptados de acordo com o movimento humano esperado. 

Através dos testes realizados pode-se perceber certas limitações com o uso do sensor Kinect, sendo que alguns tipos de movimentos devem ser evitados para a animação do personagem. Estes gestos podem ser feitos manualmente no Blender ou ajustados posteriormente, ou seja, após os \textit{keyframes} forem gravados. Além disso, para movimentos que geraram ruídos pode-se ter que realizar a edição da animação para a remoção dos mesmos. Na Tabela \ref{tab:gestos} tem-se os gestos realizados, bem como a reação obtida através dos testes.

\newpage
\begin{table}[!ht]
		\scriptsize 
		\centering
		\caption{Tabela de gestos para reconhecimento.}
    \label{tab:gestos}
    \begin{tabular}{| p{3cm} | l | p{5cm} |}
    \hline
    Gesto & Representação & Reação Obtida\\ \hline
		Inclinar a cabeça & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/head1.png}} & Personagem inclinou a cabeça de forma proporcional ao movimento realizado \\ \hline
    Inclinar o corpo & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/torso1.png}} & Personagem inclinou o corpo de forma proporcional ao movimento realizado. Foi detectada uma pequena elevação da perna oposta ao movimento \\ \hline
    Mover o braço horizontalmente & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm1.png}} & Personagem moveu o braço horizontalmente. Pequenos ruídos foram detectados com os braços na frente do corpo \\ \hline
    Mover o braço verticalmente & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Personagem moveu o braço verticalmente \\ \hline
    Mover a perna horizontalmente & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Personagem moveu a perna com um movimento mais sutil devido ao tipo de modelagem realizada. Ao passar uma perna sobre a outra ruídos foram detectados \\ \hline
    Mover a perna verticalmente & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Personagem moveu a perna de forma proporcional ao movimento. Ao mover a perna para trás obteve-se ruído \\ \hline
    Mover-se para os lados & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Personagem moveu-se de forma proporcional \\ \hline
    Mover-se para frente e para trás & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Personagem moveu-se para trás até os limites do Kinect, e para frente até uma distância de aproximadamente 2,5m do sensor \\ \hline
    Pular & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Personagem pulou de forma proporcional ao movimento \\ \hline
    Girar a cabeça & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Movimento não-suportado \\ \hline
		Girar os punhos & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Movimento não-suportado \\ \hline
    Girar o corpo em 360 graus & \adjustbox{valign=m}{\includegraphics[height=40px]{imagens/arm2.png}} & Personagem girou o corpo, porém com muitos ruídos\\ \hline
    \end{tabular}
\end{table}

\section{Animação}
Após o desenvolvimento da aplicação, foi desenvolvida uma animação simples de um personagem 3D no Blender, através dos movimentos realizados pelo usuário. A animação gerada faz com que um cachorro de desenho animado dance num palco. O modelo e cenário utilizados foram modelados manualmente, assim como seu \textit{armature}, sendo utilizada a técnica de cópia de movimentos descrita anteriormente. A dança é feita de forma simples, com o objetivo de repassar a naturalidade do movimento humano para o personagem. Na Figura \ref{fig:jake} tem-se a modelagem do cachorro utilizada na animação. Já no CD em anexo tem-se a animação gerada.

\begin{figure}[htbp]
 \centering
 \includegraphics[height=200px]{imagens/Jake.png}
 \caption{Modelo 3D utilizado na animação.}
 \label{fig:jake}
\end{figure}

